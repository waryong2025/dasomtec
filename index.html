<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>범용 근무 현황표 관리</title>
   <style>
        body {
            font-family: Arial, sans-serif;
            margin: 10px;
            background-color: #e9ecef; /* 배경색 변경 */
            color: #333;
            font-size: 14pt;
        }
        
        /* 1. 컨트롤 박스 전체를 CSS Grid로 변경 (4개 박스 자동 배치) */
        .controls {
            background-color: #fff;
            padding: 15px; border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* 전체 컨테이너 그림자 강화 */
            margin-bottom: 20px;
            display: grid;
            /* 최소 300px 크기로 열을 자동으로 채움 (4개 박스 유동 배치) */
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            align-items: stretch; /* 높이를 맞춤 */
        }

        /* 2. 각 fieldset에 돌출 효과 및 그라데이션 적용 */
        .controls fieldset {
            border: 1px solid #ced4da;
            border-radius: 8px;
            padding: 10px 15px;
            margin: 0;
            /* 연한 그라데이션 배경 추가 */
            background: linear-gradient(145deg, #ffffff, #f0f0f5); 
            /* 돌출 효과를 위한 그림자 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); 
            min-width: 300px; 
            display: flex;
            flex-direction: column;
            gap: 10px; 
            transition: transform 0.2s;
        }
        
        .controls fieldset:hover {
             box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2); /* 마우스 오버 시 그림자 강화 */
             transform: translateY(-2px);
        }

        /* 3. Legend 스타일 (구분 강조) */
        .controls fieldset legend {
            font-weight: bold;
            font-size: 1.2em;
            color: #0056b3;
            padding: 2px 10px;
            border-radius: 4px;
            background-color: #eaf4ff; /* 밝은 배경색 */
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .controls .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 5px;
        }
        .controls label { font-weight: bold; margin-right: 5px; white-space: nowrap; }
        .controls input[type="text"],
        .controls input[type="number"], 
        .controls select {
            padding: 6px;
            border: 1px solid #a8c8e1; /* 테두리 색상 변경 */
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05); /* 약간의 인셋 그림자 */
        }
        
        .controls input[type="number"] { width: 70px; }
        
        /* 회사명/종류가 별도 줄로 분리되면서 flex 속성을 수정하여 남은 공간을 채우도록 함 */
        .controls input#companyInput {
            flex: 1 1 auto; 
            min-width: 150px;
        }
        .controls select#typeSelect {
            flex: 1 1 auto; /* 이제 전체 너비를 사용 */
            min-width: 150px;
        }
        
        .controls select { flex-grow: 1; min-width: 120px; }

        /* 차량번호 입력란 컨테이너 */
        #vehicleInputsContainer {
            display: flex; flex-wrap: wrap; gap: 5px;
            width: 100%;
            margin-top: 5px;
            padding: 5px;
            background: #e9f0f6; /* 차량 입력 배경색 변경 */
            border-radius: 4px;
            border: 1px solid #cfe2f3;
        }
        #vehicleInputsContainer input {
            width: 80px;
            font-size: 0.9em;
            padding: 4px;
        }

        /* 인쇄 옵션 */
        .controls select.margin-select {
            width: 55px; padding: 1px 3px;
            font-size: 0.9em; flex-grow: 0;
        }
        
        /* 버튼 및 특수 셀렉트 박스 */
        .controls button,
        .controls select.action-select,
        .controls select.work-type-select,
        .controls select.vehicle-select {
            padding: 8px 15px;
            color: white; border: none; border-radius: 4px;
            cursor: pointer; font-size: 17.5px;
            text-decoration: none; display: inline-block;
            text-align: center; white-space: nowrap;
            width: auto;
            flex-grow: 0; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15); /* 버튼에도 그림자 */
        }
        
        .controls button { background-color: #007bff; }
        .controls button:hover { background-color: #0056b3; }
        .controls button.btn-danger { background-color: #dc3545; }
        .controls button.btn-danger:hover { background-color: #c82333; }
        
        .controls select.action-select { background-color: #28a745; }
        .controls select.work-type-select { background-color: #ffc107; color: #333; }
        .controls select.vehicle-select { background-color: #6c757d; }
        .controls select.route-navigate-select {
            padding: 8px 15px;
            font-size: 17.5px;
            background-color: #17a2b8; 
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            width: 100%; 
        }

        /* 법정휴무일 옵션 스타일 (배경색, 작은 박스) */
        .holiday-option-group {
            background-color: #e3f2fd; /* 배경색 변경 (더 밝게) */
            padding: 8px;
            border-radius: 5px;
            align-items: center;
            border: 1px solid #b3e5fc;
        }
        .holiday-option-group select {
            padding: 4px;
            font-size: 0.9em;
            flex-grow: 0; 
            width: 100px;
        }

        #scheduleContainer {
            background-color: white;
            padding: 10px; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* 테이블 컨테이너 그림자 */
            margin: 20px auto; max-width: 95%; overflow-x: auto;
            border-radius: 8px;
        }
        table {
            width: 100%;
            min-width: 1200px; border-collapse: collapse;
            margin: 0 auto; font-size: 0.9em; background-color: #fff; table-layout: fixed;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 5px; 
            text-align: center;
            vertical-align: middle; 
            line-height: 1.2; 
            word-break: keep-all;
            height: 38px; box-sizing: border-box;
            font-size: 13pt;
        }
        th { background-color: #f2f2f2; font-weight: bold; }
        caption {
            font-size: 1.5em;
            margin-bottom: 10px; font-weight: bold;
            color: #333; text-decoration: underline;
        }
        .sunday { background-color: #ffe0e0; }
        .saturday { background-color: #e0e0ff; }
        .holiday { background-color: #ffcccc; font-weight: bold; color: #cc0000; }
        
        /* 공휴일 이름 스타일 */
        .holiday-name {
            display: block;
            font-size: 0.6em; 
            line-height: 1.2;
            font-weight: bold;
            color: #cc0000;
        }
        
        .edit-mode {
            position: relative;
            padding: 2px; display: flex; flex-direction: column;
            justify-content: center; height: 100%;
            vertical-align: middle; 
        }
        .edit-mode input {
            width: calc(100% - 8px);
            margin-bottom: 2px;
            padding: 2px; box-sizing: border-box;
        }
        .edit-mode .cell-buttons { display: flex;
            justify-content: space-around; margin-top: 2px; }
            
        /* 수정모드 셀 내부 버튼 스타일 및 색상 */
        .edit-mode .cell-buttons button {
            padding: 3px 5px;
            font-size: 0.7em; 
            color: white; 
            border: none;
            border-radius: 3px; 
            cursor: pointer; 
            white-space: nowrap;
            transition: background-color 0.15s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            flex-grow: 1; 
            margin: 0 1px; 
        }
        
        .edit-mode .cell-buttons button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
        }

        .edit-mode .cell-buttons .btn-fixed { background-color: #007bff; }
        .edit-mode .cell-buttons .btn-fixed:hover:not(:disabled) { background-color: #0056b3; }
        .edit-mode .cell-buttons .btn-temp { background-color: #28a745; }
        .edit-mode .cell-buttons .btn-temp:hover { background-color: #1e7e34; }
        .edit-mode .cell-buttons .btn-highlight-am { background-color: #6f42c1; }
        .edit-mode .cell-buttons .btn-highlight-am:hover { background-color: #5a349c; }
        .edit-mode .cell-buttons .btn-highlight-pm { background-color: #fd7e14; }
        .edit-mode .cell-buttons .btn-highlight-pm:hover { background-color: #db6a0b; }
        .edit-mode .cell-buttons .btn-delete { background-color: #dc3545; }
        .edit-mode .cell-buttons .btn-delete:hover { background-color: #c82333; }


        .name-entry { display: block; margin-top: 2px; margin-bottom: 2px; }
        .hidden-x { color: white; }
        /* ✅ 수정된 부분: 저장 후에도 강조가 유지되도록 font-weight: bold 추가 */
        .name-entry.bold-name {
            font-weight: bold;
        }
        table th:nth-child(1),
        table td:nth-child(1),
        table th:nth-child(2),
        table td:nth-child(2) {
            width: 4%;
            min-width: 60px;
            vertical-align: middle; 
        }

        @media screen and (max-width: 1400px) {
            /* 화면이 줄어들면 3열 배치 시도 */
            .controls {
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            }
        }

        @media screen and (max-width: 768px) {
            /* 768px 이하일 때 1열로 변경 */
            .controls {
                grid-template-columns: 1fr;
            }
            .controls .control-group { flex-direction: column; align-items: stretch; }
            .controls input[type="text"], .controls input[type="number"], .controls select,
            .controls input#companyInput, .controls select#typeSelect { 
                width: 100%; 
                flex-basis: auto;
            }
        }

        /* 프린트 스타일은 이전과 동일하게 유지 */
        @media print {
            @page {
                size: A4;
                margin: 10mm;
                margin-left: var(--print-margin-left, 15mm);
                margin-right: var(--print-margin-right, 5mm);
            }
            body { background-color: white; margin: 0; padding: 0; -webkit-print-color-adjust: exact; }
            .controls { display: none; }
            #scheduleContainer { box-shadow: none; margin: 0; padding: 0; }
            table { width: 100%; min-width: unset; font-size: 0.8em; border: 1px solid #000; table-layout: fixed; }
            th, td { padding: 1px; height: auto; word-break: break-all; vertical-align: top; }
            table th:nth-child(1), table td:nth-child(1),
            table th:nth-child(2), table td:nth-child(2) { 
                width: 4%;
                vertical-align: middle; 
            }
            .holiday-name { font-size: 0.7em; }
        }
    </style>
</head>
<body>
    <div class="controls">

        <fieldset>
            <legend>회사 / 노선 정보</legend>
            
            <div class="control-group">
                <label for="companyInput">회사명:</label>
                <input type="text" id="companyInput" placeholder="예: 와룡운수">
            </div>

            <div class="control-group">
                <label for="typeSelect">버스 종류 선택:</label>
                <select id="typeSelect">
                    <option value="마을">마을</option>
                    <option value="버스">버스</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="routeInput">노선 번호:</label>
                <input type="text" id="routeInput" placeholder="예: 종로08">
                <button onclick="addOrUpdateRoute()">노선 추가/수정</button>
                <button onclick="deleteRoute()" class="btn-danger">선택 노선 삭제</button>
            </div>
        </fieldset>

        <fieldset>
            <legend>조회 설정</legend>
            <div class="control-group">
                <label for="yearInput">년도:</label>
                <input type="number" id="yearInput" value="2025">
                <label for="monthInput">월:</label>
                <input type="number" id="monthInput" value="9">
                <button onclick="generateSchedule()">생성</button>
            </div>
            <div class="control-group">
                <input type="radio" id="option1" name="displayOption" value="1">
                <label for="option1">1일 ~ 15일</label>
                <input type="radio" id="option2" name="displayOption" value="2" checked>
                <label for="option2">16일 ~ 말일</label>
            </div>
            <div class="control-group holiday-option-group">
                <label for="holidaySelect">법정휴무일:</label>
                <select id="holidaySelect">
                    <option value="apply">적용</option>
                    <option value="ignore">미적용</option>
                </select>
            </div>
        </fieldset>

        <fieldset>
            <legend>근무현황관리옵션</legend>
            
            <div class="control-group">
                <label for="routeNavigateSelect">관련 노선 이동:</label>
                <select id="routeNavigateSelect" class="route-navigate-select" onchange="handleRouteSelectChange(this.value)"></select>
            </div>
            
            <div class="control-group">
                <button onclick="printPage()">인쇄</button>
                <div style="display: flex; flex-direction: column; gap: 2px; margin-left: 5px;">
                    <div style="display: flex; align-items: center; gap: 3px; font-size: 0.9em; height: 18px;">
                        <label for="marginLeftSelect">좌측:</label>
                        <select id="marginLeftSelect" class="margin-select">
                            <option value="0">0</option><option value="10" selected>10</option><option value="20">20</option><option value="30">30</option><option value="40">40</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 3px; font-size: 0.9em; height: 18px;">
                        <label for="marginRightSelect">우측:</label>
                        <select id="marginRightSelect" class="margin-select">
                            <option value="0">0</option><option value="10">10</option><option value="20">20</option><option value="30">30</option><option value="40">40</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <select id="scheduleActionsSelect" class="action-select" onchange="handleScheduleActions()">
                    <option value="">근무표 관리 옵션</option>
                    <option value="reset">현재 노선 초기화</option>
                    <option value="backup">전체 데이터 백업</option>
                    <option value="restore">전체 데이터 복구</option>
                </select>
                <input type="file" id="restoreFile" style="display: none;" onchange="restoreScheduleData(this.files[0])" accept=".json">
                
                <button onclick="calculateWorkdays()">근무일수계산</button>
            </div>
            
            <div class="control-group">
                <select id="vehicleSelect" class="vehicle-select">
                    <option value="">차량 선택</option>
                    </select>
                <select id="workTypeSelect" class="work-type-select" onchange="handleWorkTypeChange()">
                    <option value="">근무조건 선택</option>
                    <option value="normal">3/3 근무</option>
                    <option value="biweekly">격주 근무</option>
                </select>
            </div>
        </fieldset>
        
        <fieldset>
            <legend>차량 설정 (현재 노선)</legend>
            <div class="control-group">
                <label for="vehicleCountInput">차량 수:</label>
                <input type="number" id="vehicleCountInput" value="11" min="1" max="50" onchange="handleVehicleCountChange(this.value)">
                <button onclick="saveRouteConfig()">차량 번호 저장</button>
            </div>
            <div class="control-group" style="flex-direction: column; align-items: flex-start;">
                <label>차량 번호 (총 <span id="vehicleCountDisplay">0</span>대):</label>
                <div id="vehicleInputsContainer">
                    </div>
            </div>
        </fieldset>
        
    </div>

    <div id="scheduleContainer">
        <table>
            <caption id="tableCaption">근무 현황표를 생성해주세요.</caption>
            <thead id="scheduleHeader">
            </thead>
            <tbody id="scheduleBody">
            </tbody>
        </table>
    </div>

    <script>
        // --- 마스터 데이터 관리 ---
        const MASTER_STORAGE_KEY = 'busScheduleManagerData';
        
        let allRoutesData = {
            currentRoute: null, 
            routes: {} 
        };

        let currentRoute = null;
        let currentVehicleColumns = [];
        
        let fixedScheduleData = {};
        let tempScheduleData = {};
        let workTypeConfig = {};
        
        let scheduleData = {}; 

        // 2025년 공휴일 데이터 (이름 포함)
        const publicHolidays2025 = {
            '01-01': '신정', '01-28': '설날', '01-29': '설날', '01-30': '설날',
            '03-01': '삼일절', '05-05': '어린이날', '05-06': '부처님오신날',
            '06-06': '현충일', '08-15': '광복절', '10-05': '추석',
            '10-06': '추석', '10-07': '추석', '10-09': '한글날', '12-25': '성탄절'
        };

        // --- 핵심 로직 함수 ---

        function loadMasterData() {
            const storedData = localStorage.getItem(MASTER_STORAGE_KEY);
            if (storedData) {
                allRoutesData = JSON.parse(storedData);
                currentRoute = allRoutesData.currentRoute || Object.keys(allRoutesData.routes)[0];
            } else {
                allRoutesData = { currentRoute: null, routes: {} };
                currentRoute = null;
            }
            if (!currentRoute || !allRoutesData.routes[currentRoute]) {
                currentRoute = Object.keys(allRoutesData.routes)[0] || null; 
                allRoutesData.currentRoute = currentRoute;
            }
        }

        function saveMasterData() {
            allRoutesData.currentRoute = currentRoute;
            localStorage.setItem(MASTER_STORAGE_KEY, JSON.stringify(allRoutesData));
        }

        function populateRouteSelect() {
            const routeSelect = document.getElementById('routeNavigateSelect');
            routeSelect.innerHTML = ''; 
            const routeNames = Object.keys(allRoutesData.routes);

            if (routeNames.length === 0) {
                routeSelect.innerHTML = '<option value="">노선을 추가하세요</option>';
                return;
            }
            
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '--- 노선 이동 ---';
            routeSelect.appendChild(defaultOption);

            routeNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                if (name === currentRoute) {
                    option.selected = true;
                }
                routeSelect.appendChild(option);
            });
        }

        function loadRouteData(routeName) {
            const routeNavSelect = document.getElementById('routeNavigateSelect');

            if (!routeName || !allRoutesData.routes[routeName]) {
                // UI 초기화
                document.getElementById('routeInput').value = '';
                document.getElementById('companyInput').value = '';
                document.getElementById('typeSelect').value = '마을';
                document.getElementById('vehicleCountInput').value = 0;
                handleVehicleCountChange(0);
                
                fixedScheduleData = {};
                tempScheduleData = {};
                workTypeConfig = {};
                currentVehicleColumns = [];
                currentRoute = null;
                allRoutesData.currentRoute = null;
                
                updateVehicleSelect();
                if (routeNavSelect) {
                    routeNavSelect.value = '';
                }
                saveMasterData(); 
                generateSchedule(); 
                return;
            }

            currentRoute = routeName;
            allRoutesData.currentRoute = routeName; 
            const routeData = allRoutesData.routes[routeName];

            fixedScheduleData = routeData.fixedSchedule;
            tempScheduleData = routeData.tempSchedule;
            workTypeConfig = routeData.workTypeConfig;
            currentVehicleColumns = routeData.vehicleColumns || [];

            document.getElementById('routeInput').value = routeName;
            document.getElementById('companyInput').value = routeData.companyName || '';
            document.getElementById('typeSelect').value = routeData.type || '마을';
            document.getElementById('vehicleCountInput').value = currentVehicleColumns.length;

            handleVehicleCountChange(currentVehicleColumns.length);
            const inputs = document.querySelectorAll('#vehicleInputsContainer input');
            inputs.forEach((input, index) => {
                if (currentVehicleColumns[index]) {
                    input.value = currentVehicleColumns[index];
                }
            });

            updateVehicleSelect();
            
            if (routeNavSelect) {
                routeNavSelect.value = routeName;
            }
            
            saveMasterData(); 
            generateSchedule(); 
        }

        function addOrUpdateRoute() {
            const routeName = document.getElementById('routeInput').value.trim();
            if (!routeName) {
                alert('노선 번호를 입력하세요.');
                return;
            }

            const companyName = document.getElementById('companyInput').value.trim();
            const type = document.getElementById('typeSelect').value;
            
            if (!allRoutesData.routes[routeName]) {
                // 새 노선 추가
                allRoutesData.routes[routeName] = {
                    companyName: companyName,
                    type: type,
                    vehicleColumns: ['차량1'], 
                    fixedSchedule: {},
                    tempSchedule: {},
                    workTypeConfig: {}
                };
                alert(`새 노선 [${routeName}]이 추가되었습니다. 차량 수와 차량 번호를 설정하세요.`);
            } else {
                // 기존 노선 정보 업데이트 (회사명, 종류만)
                allRoutesData.routes[routeName].companyName = companyName;
                allRoutesData.routes[routeName].type = type;
                alert(`[${routeName}] 노선 정보 (회사명, 종류)가 수정되었습니다.`);
            }

            currentRoute = routeName;
            saveMasterData();
            populateRouteSelect(); 
            loadRouteData(routeName); 
        }

        function deleteRoute() {
            const routeName = document.getElementById('routeNavigateSelect').value;
            if (!routeName) {
                alert('삭제할 노선을 [관련 노선 이동] 드롭다운에서 선택하세요.');
                return;
            }

            if (confirm(`[${routeName}] 노선을 정말로 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`)) {
                delete allRoutesData.routes[routeName];
                
                const newRouteToLoad = Object.keys(allRoutesData.routes)[0] || null;
                
                currentRoute = newRouteToLoad; 
                allRoutesData.currentRoute = newRouteToLoad; 

                saveMasterData();
                populateRouteSelect(); 
                loadRouteData(newRouteToLoad); 
                
                alert(`[${routeName}] 노선이 삭제되었습니다.`);
            }
        }


        function saveRouteConfig() {
            if (!currentRoute) {
                alert('먼저 노선을 선택하거나 추가하세요.');
                return;
            }
            const routeData = allRoutesData.routes[currentRoute];
            if (!routeData) {
                alert('현재 노선에 대한 데이터가 없습니다.');
                return;
            }

            const inputs = document.querySelectorAll('#vehicleInputsContainer input');
            const newVehicleColumns = [];
            inputs.forEach(input => {
                newVehicleColumns.push(input.value.trim() || '미입력');
            });

            routeData.vehicleColumns = newVehicleColumns;
            currentVehicleColumns = newVehicleColumns; 

            saveMasterData();
            updateVehicleSelect(); 
            generateSchedule(); 
            
            alert(`[${currentRoute}] 노선의 차량 번호가 저장되었습니다.`);
        }

        function handleVehicleCountChange(countStr) {
            const count = parseInt(countStr) || 0;
            document.getElementById('vehicleCountDisplay').textContent = count;
            const container = document.getElementById('vehicleInputsContainer');
            container.innerHTML = ''; 

            const existingColumns = (currentRoute && allRoutesData.routes[currentRoute]) 
                                    ? allRoutesData.routes[currentRoute].vehicleColumns 
                                    : [];

            for (let i = 0; i < count; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = `차량 ${i + 1}`;
                input.value = existingColumns[i] || '';
                container.appendChild(input);
            }
        }
        
        function updateVehicleSelect() {
            const vehicleSelect = document.getElementById('vehicleSelect');
            vehicleSelect.innerHTML = '<option value="">차량 선택</option>';
            currentVehicleColumns.forEach(colName => {
                if(colName) { 
                    const option = document.createElement('option');
                    option.value = colName;
                    option.textContent = colName;
                    vehicleSelect.appendChild(option);
                }
            });
        }

        function getDayName(dayOfWeek) {
            const days = ['일', '월', '화', '수', '목', '금', '토'];
            return days[dayOfWeek];
        }
        
        function isPublicHoliday(date) {
            const year = date.getFullYear();
            if (year !== 2025) return false; 
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const mmdd = `${month}-${day}`;
            return publicHolidays2025[mmdd] || false; 
        }

        function renderCellContent(names) {
            if (!names || names.length === 0) return '';
            return names.map(item => {
                const text = item.text.trim();
                const display = text === '' ? '.' : text;
                const hiddenClass = text === '' ? ' hidden-x' : '';
                // item.bold가 true일 때 'bold-name' 클래스를 추가합니다.
                const boldClass = item.bold ? ' bold-name' : ''; 
                return `<span class="name-entry${hiddenClass}${boldClass}">${display}</span>`;
            }).join('');
        }

        function editCell(cell, colId, dateString, dayOfWeek) {
            if (cell.classList.contains('edit-mode')) return;
            document.querySelectorAll('td.edit-mode').forEach(editCell => {
                const prevColId = editCell.dataset.colId;
                const prevDateString = editCell.dataset.dateString;
                const originalNames = (scheduleData[prevDateString] && scheduleData[prevDateString][prevColId]) || [{ text: '', bold: false }, { text: '', bold: false }];
                editCell.classList.remove('edit-mode');
                editCell.innerHTML = renderCellContent(originalNames);
            });
            
            const currentNames = (scheduleData[dateString] && scheduleData[dateString][colId]) || [{ text: '', bold: false }, { text: '', bold: false }];
            const morningValue = currentNames[0] ? currentNames[0].text : '';
            const afternoonValue = currentNames[1] ? currentNames[1].text : '';
            const isBiweeklySunday = (workTypeConfig[colId] === 'biweekly' && dayOfWeek === 0);

            cell.classList.add('edit-mode');
            cell.dataset.colId = colId;
            cell.dataset.dateString = dateString;
            cell.dataset.dayOfWeek = dayOfWeek;
            cell.innerHTML = `
                <input type="text" class="morning-input" value="${morningValue}" placeholder="오전" data-bold="${currentNames[0].bold}">
                <input type="text" class="afternoon-input" value="${afternoonValue}" placeholder="오후" data-bold="${currentNames[1].bold}">
                <div class="cell-buttons">
                    <button class="btn-fixed" onclick="saveFixedCell(this.parentNode.parentNode)" ${isBiweeklySunday ? 'disabled title="격주 근무 차량은 일요일 고정 저장이 불가능합니다."' : ''}>고정</button>
                    <button class="btn-temp" onclick="saveTempCell(this.parentNode.parentNode)">임시</button>
                    <button class="btn-highlight-am" onclick="highlightCell(this.parentNode.parentNode, 'am')">오전 강조</button>
                    <button class="btn-highlight-pm" onclick="highlightCell(this.parentNode.parentNode, 'pm')">오후 강조</button>
                    <button class="btn-delete" onclick="deleteCell(this.parentNode.parentNode)">삭제</button>
                </div>
            `;
            cell.querySelector('.morning-input').focus();
        }
        
        function clearEditMode(event) {
            if (event.target.matches('td:nth-child(1)') || event.target.matches('td:nth-child(2)')) {
                const editCell = document.querySelector('td.edit-mode');
                if (editCell) {
                    const prevColId = editCell.dataset.colId;
                    const prevDateString = editCell.dataset.dateString;
                    const originalNames = (scheduleData[prevDateString] && scheduleData[prevDateString][prevColId]) || [{ text: '', bold: false }, { text: '', bold: false }];
                    editCell.classList.remove('edit-mode');
                    editCell.innerHTML = renderCellContent(originalNames);
                }
            }
        }

        function getNamesAndBoldStateFromCell(cellElement) {
            const morningInput = cellElement.querySelector('.morning-input');
            const afternoonInput = cellElement.querySelector('.afternoon-input');
            const morningText = morningInput.value.trim();
            const afternoonText = afternoonInput.value.trim();
            // data-bold 속성 값을 boolean으로 정확히 읽어 저장합니다.
            const morningBold = morningInput.dataset.bold === 'true';
            const afternoonBold = afternoonInput.dataset.bold === 'true';
            return [ { text: morningText, bold: morningBold }, { text: afternoonText, bold: afternoonBold } ];
        }

        function highlightCell(cellElement, timeOfDay) {
            let inputElement;
            if (timeOfDay === 'am') inputElement = cellElement.querySelector('.morning-input');
            else if (timeOfDay === 'pm') inputElement = cellElement.querySelector('.afternoon-input');
            if (inputElement) {
                const isCurrentlyBold = inputElement.dataset.bold === 'true';
                const newState = !isCurrentlyBold;
                inputElement.dataset.bold = newState; // data 속성 업데이트 (저장될 값)
                inputElement.style.fontWeight = newState ? 'bold' : 'normal'; // 현재 UI에 굵은 글씨 적용 (수정 모드에만 보임)
            }
        }

        function saveFixedCell(cellElement) {
            const { colId, dayOfWeek, dateString } = cellElement.dataset;
            const namesToSave = getNamesAndBoldStateFromCell(cellElement);
            const workType = workTypeConfig[colId] || 'normal';

            if (workType === 'biweekly' && dayOfWeek === '0') {
                alert('격주 근무 차량은 일요일 고정 저장이 불가능합니다.');
                return;
            }

            const currentRecurringKey = `${dayOfWeek}-${colId}`;
            if (!fixedScheduleData[currentRecurringKey]) {
                fixedScheduleData[currentRecurringKey] = [];
            }
            fixedScheduleData[currentRecurringKey] = fixedScheduleData[currentRecurringKey].filter(
                entry => entry.dateString !== dateString
            );
            fixedScheduleData[currentRecurringKey].push({ dateString: dateString, names: namesToSave });

            if (workType === 'biweekly' && dayOfWeek !== '0') {
                const rotatedNames = [ namesToSave[1], namesToSave[0] ];
                const currentDate = new Date(dateString);
                currentDate.setDate(currentDate.getDate() + 7);
                const nextWeekDateString = currentDate.toISOString().slice(0, 10);
                const nextWeekRecurringKey = currentRecurringKey;
                if (!fixedScheduleData[nextWeekRecurringKey]) {
                    fixedScheduleData[nextWeekRecurringKey] = [];
                }
                fixedScheduleData[nextWeekRecurringKey] = fixedScheduleData[nextWeekRecurringKey].filter(
                    entry => entry.dateString !== nextWeekDateString
                );
                fixedScheduleData[nextWeekRecurringKey].push({ dateString: nextWeekDateString, names: rotatedNames });
            }

            for (const key in fixedScheduleData) {
                fixedScheduleData[key].sort((a, b) => new Date(b.dateString) - new Date(a.dateString));
            }
            saveMasterData();
            generateSchedule();
        }

        function saveTempCell(cellElement) {
            const { colId, dateString } = cellElement.dataset;
            const namesToSave = getNamesAndBoldStateFromCell(cellElement);
            if (!tempScheduleData[dateString]) tempScheduleData[dateString] = {};
            tempScheduleData[dateString][colId] = namesToSave;
            saveMasterData();
            generateSchedule();
        }

        function deleteCell(cellElement) {
            const { colId, dayOfWeek, dateString } = cellElement.dataset;

            if (tempScheduleData[dateString]?.[colId]) {
                delete tempScheduleData[dateString][colId];
                if (Object.keys(tempScheduleData[dateString]).length === 0) {
                    delete tempScheduleData[dateString];
                }
            }

            const recurringKey = `${dayOfWeek}-${colId}`;
            if (fixedScheduleData[recurringKey]) {
                const blankNames = [{ text: '', bold: false }, { text: '', bold: false }];
                fixedScheduleData[recurringKey] = fixedScheduleData[recurringKey].filter(entry => entry.dateString !== dateString);
                fixedScheduleData[recurringKey].push({ dateString: dateString, names: blankNames });
                fixedScheduleData[recurringKey].sort((a, b) => new Date(b.dateString) - new Date(a.dateString));
            }
            saveMasterData();
            generateSchedule();
        }

        function resetAllFixedSchedules() {
            if (!currentRoute) {
                alert('초기화할 노선이 선택되지 않았습니다.');
                return;
            }
            const password = prompt(`[${currentRoute}] 노선의 모든 고정/임시 근무표 및 근무형태 설정을 삭제하시려면 비밀번호를 입력하세요.`);
            if (password === "201023") {
                if (confirm(`[${currentRoute}] 노선의 모든 근무표 데이터를 삭제합니다. 계속하시겠습니까?`)) {
                    const routeData = allRoutesData.routes[currentRoute];
                    if (routeData) {
                        routeData.fixedSchedule = {};
                        routeData.tempSchedule = {};
                        routeData.workTypeConfig = {};
                        fixedScheduleData = routeData.fixedSchedule;
                        tempScheduleData = routeData.tempSchedule;
                        workTypeConfig = routeData.workTypeConfig;
                        saveMasterData();
                        generateSchedule();
                        alert(`[${currentRoute}] 노선의 근무표가 초기화되었습니다.`);
                    }
                }
            } else {
                alert("비밀번호 확인 후 신청하세요.");
            }
        }

        function backupScheduleData() {
            const backupData = allRoutesData;
            const jsonString = JSON.stringify(backupData);
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;

            // ✅ 수정된 부분: 현재 노선 번호를 파일명에 포함
            const routeIdentifier = (currentRoute ? currentRoute.replace(/\s/g, '') : 'all');
            const filename = `bus_schedule_${routeIdentifier}_backup_${timestamp}.json`;

            const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            alert(`전체 근무표 백업 데이터 파일 (${filename})이 다운로드 폴더에 JSON 파일로 저장됩니다.`);
        }

        function restoreScheduleData(file) {
            const selectElement = document.getElementById('scheduleActionsSelect');
            if (!file) {
                selectElement.value = '';
                return;
            }
            if (!confirm(`[${file.name}] 파일을 업로드하여 저장된 *모든* 노선의 근무표를 복구하시겠습니까? (현재 모든 데이터는 덮어쓰여집니다.)`)) {
                document.getElementById('restoreFile').value = '';
                selectElement.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const loadedData = JSON.parse(event.target.result);
                    if (!loadedData.routes || loadedData.currentRoute === undefined) {
                         alert('파일 형식이 올바르지 않거나 데이터가 부족합니다. (routes, currentRoute 속성 필요)');
                         throw new Error('Invalid backup file structure');
                    }
                    allRoutesData = loadedData;
                    currentRoute = allRoutesData.currentRoute; 
                    saveMasterData();
                    populateRouteSelect();
                    loadRouteData(currentRoute);
                    alert(`[${file.name}] 파일로부터 전체 데이터 복구를 완료했습니다. 화면을 확인해주세요.`);
                } catch (e) {
                    alert('파일을 읽는 도중 오류가 발생했습니다. 파일이 손상되었거나 JSON 형식이 아닙니다.');
                    console.error('Restore Error:', e);
                } finally {
                    document.getElementById('restoreFile').value = '';
                    selectElement.value = '';
                }
            };
            reader.onerror = function() {
                alert('파일을 읽을 수 없습니다.');
                document.getElementById('restoreFile').value = '';
                selectElement.value = '';
            };
            reader.readAsText(file);
        }

        function generateSchedule() {
            if (!currentRoute || !allRoutesData.routes[currentRoute]) {
                document.getElementById('tableCaption').textContent = '표시할 노선을 선택하거나 추가해주세요.';
                document.getElementById('scheduleHeader').innerHTML = '';
                document.getElementById('scheduleBody').innerHTML = '';
                return;
            }

            const year = parseInt(document.getElementById('yearInput').value);
            const month = parseInt(document.getElementById('monthInput').value);
            const selectedOption = document.querySelector('input[name="displayOption"]:checked').value;
            const applyHolidays = document.getElementById('holidaySelect').value === 'apply';
            const routeData = allRoutesData.routes[currentRoute];
            const companyName = routeData.companyName || '회사명 없음';
            const VEHICLE_COLS = routeData.vehicleColumns || [];

            const scheduleHeader = document.getElementById('scheduleHeader');
            const scheduleBody = document.getElementById('scheduleBody');
            const tableCaption = document.getElementById('tableCaption');
            
            const headerHTML = `<tr><th style="width: 4%;">월일</th><th style="width: 4%;">요일</th>${VEHICLE_COLS.map(c => `<th>${c}</th>`).join('')}</tr>`;
            scheduleHeader.innerHTML = headerHTML;
            scheduleBody.innerHTML = '';

            const startDate = new Date(year, month - 1, selectedOption === '1' ? 1 : 16);
            const endDate = (selectedOption === '1') ? new Date(year, month - 1, 15) : new Date(year, month, 0);

            tableCaption.textContent = `${companyName} [${currentRoute}] ${year}년 ${month}월 ${startDate.getDate()}일 ~ ${endDate.getDate()}일까지 근무현황표`;

            scheduleData = {};

            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const dateString = d.toISOString().slice(0, 10);
                const dayOfWeek = d.getDay();
                let cellsContent = {};
                VEHICLE_COLS.forEach(colId => {
                    let appliedNames = [{ text: '', bold: false }, { text: '', bold: false }];
                    if (tempScheduleData[dateString] && tempScheduleData[dateString][colId]) {
                        appliedNames = tempScheduleData[dateString][colId];
                    } else {
                        const recurringKey = `${dayOfWeek}-${colId}`;
                        if (fixedScheduleData[recurringKey]) {
                            for (const entry of fixedScheduleData[recurringKey]) {
                                if (new Date(dateString) >= new Date(entry.dateString)) {
                                    appliedNames = entry.names;
                                    break;
                                }
                            }
                        }
                    }
                    cellsContent[colId] = appliedNames;
                });
                scheduleData[dateString] = cellsContent;

                const holidayName = applyHolidays ? isPublicHoliday(d) : false;
                const isHoliday = !!holidayName;
                
                let rowClass = isHoliday ? 'holiday' : '';
                let dayName = getDayName(dayOfWeek); 
                
                let holidayText = '';
                if (isHoliday) {
                    holidayText = `<span class="holiday-name">${holidayName}</span>`;
                } else if (dayOfWeek === 0) {
                    rowClass = 'sunday';
                } else if (dayOfWeek === 6) {
                    rowClass = 'saturday';
                }

                const dataCellsHTML = VEHICLE_COLS.map(colId =>
                    `<td onclick="editCell(this, '${colId}', '${dateString}', ${dayOfWeek})">${renderCellContent(cellsContent[colId])}</td>`
                ).join('');
                
                scheduleBody.insertAdjacentHTML('beforeend', `
                    <tr class="${rowClass}">
                        <td>${d.getDate()}</td>
                        <td>${dayName}${holidayText}</td> 
                        ${dataCellsHTML}
                    </tr>`);
            }
        }

        function calculateWorkdays() {
            if (!currentRoute || !allRoutesData.routes[currentRoute]) {
                alert('근무일수를 계산할 노선이 없습니다.');
                return;
            }
            const year = parseInt(document.getElementById('yearInput').value);
            const month = parseInt(document.getElementById('monthInput').value);
            const VEHICLE_COLS = allRoutesData.routes[currentRoute].vehicleColumns || [];
            const workdayCounts = {};
            const shiftCounts = {};
            const allNames = new Set();
            const startDate = new Date(year, month - 1, 1);
            const endDate = new Date(year, month, 0);
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const dateString = d.toISOString().slice(0, 10);
                const dayOfWeek = d.getDay();
                let dailyNames = {};
                VEHICLE_COLS.forEach(colId => {
                    let appliedNames = [{ text: '', bold: false }, { text: '', bold: false }];
                    if (tempScheduleData[dateString] && tempScheduleData[dateString][colId]) {
                        appliedNames = tempScheduleData[dateString][colId];
                    } else {
                        const recurringKey = `${dayOfWeek}-${colId}`;
                        if (fixedScheduleData[recurringKey]) {
                            for (const entry of fixedScheduleData[recurringKey]) {
                                if (new Date(dateString) >= new Date(entry.dateString)) {
                                    appliedNames = entry.names;
                                    break;
                                }
                            }
                        }
                    }
                    dailyNames[colId] = appliedNames;
                });
                const dayWorkdays = new Set();
                for (const colId in dailyNames) {
                    if (colId !== '비고') {
                        dailyNames[colId].forEach((item, index) => {
                            const name = item.text.trim();
                            if (name !== '') {
                                allNames.add(name);
                                if (!shiftCounts[name]) shiftCounts[name] = { 오전: 0, 오후: 0 };
                                if (index === 0) shiftCounts[name].오전++;
                                else shiftCounts[name].오후++;
                                dayWorkdays.add(name);
                            }
                        });
                    }
                }
                dayWorkdays.forEach(name => {
                    if (!workdayCounts[name]) workdayCounts[name] = 0;
                    workdayCounts[name]++;
                });
            }
            const combinedData = Object.keys(workdayCounts).map(name => ({
                name: name, workdays: workdayCounts[name],
                morningShifts: (shiftCounts[name] && shiftCounts[name].오전) || 0,
                afternoonShifts: (shiftCounts[name] && shiftCounts[name].오후) || 0
            }));
            combinedData.sort((a, b) => b.workdays - a.workdays);
            const title = `[${currentRoute}] ${year}년 ${month}월 근무일수`;
            const tableHTML = `
                <table style="width: 100%; border-collapse: collapse;">
                    <thead><tr>
                        <th style="width: 25%; padding: 8px; border: 1px solid #ddd;">이름</th>
                        <th style="width: 25%; padding: 8px; border: 1px solid #ddd;">오전</th>
                        <th style="width: 25%; padding: 8px; border: 1px solid #ddd;">오후</th>
                        <th style="width: 25%; padding: 8px; border: 1px solid #ddd;">총 근무일수</th>
                    </tr></thead>
                    <tbody>${combinedData.map(data => `
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${data.name}</td>
                            <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${data.morningShifts}일</td>
                            <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${data.afternoonShifts}일</td>
                            <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${data.workdays}일</td>
                        </tr>`).join('')}
                    </tbody>
                </table>`;
            const newWindow = window.open('', '_blank', 'width=600,height=400');
            newWindow.document.write(`<html><head><title>${title}</title><style>
                body { font-family: Arial, sans-serif; margin: 20px; } h3 { text-align: center; }
                table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                th, td { border: 1px solid #ddd; padding: 10px; text-align: center; } th { background-color: #f2f2f2; }
                .print-button { display: block; margin: 20px auto; padding: 10px 20px; background-color: #007bff; color: white; border: none; cursor: pointer; border-radius: 5px; }
                @media print { .print-button { display: none; } html, body { height: 100%; width: 100%; margin: 0; } }
                </style></head><body><h3>${title}</h3>${tableHTML}<button class="print-button" onclick="window.print()">인쇄</button></body></html>`);
            newWindow.document.close();
        }

        function printPage() {
            const editCell = document.querySelector('td.edit-mode');
            if (editCell) {
                const { colId, dateString } = editCell.dataset;
                const originalNames = scheduleData[dateString]?.[colId] || [{ text: '', bold: false }, { text: '', bold: false }];
                editCell.classList.remove('edit-mode');
                editCell.innerHTML = renderCellContent(originalNames);
            }
            const marginLeft = document.getElementById('marginLeftSelect').value;
            const marginRight = document.getElementById('marginRightSelect').value;
            document.documentElement.style.setProperty('--print-margin-left', `${marginLeft}mm`);
            document.documentElement.style.setProperty('--print-margin-right', `${marginRight}mm`);
            const originalTitle = document.title;
            const captionText = document.getElementById('tableCaption').textContent;
            let newTitle = "근무현황표";
            const matches = captionText.match(/\[(.*?)\] (\d{4})년 (\d{1,2})월 (\d{1,2})일 ~ (\d{1,2})일/);
            if (matches) {
                const routeName = matches[1];
                const year = matches[2];
                const month = matches[3].padStart(2, '0');
                const startDay = matches[4].padStart(2, '0');
                const endDay = matches[5].padStart(2, '0');
                newTitle = `${routeName} ${year}-${month} (${startDay}일-${endDay}일)`;
            } else if (currentRoute) {
                newTitle = `${currentRoute} 근무현황표`;
            }
            const handleAfterPrint = () => {
                document.title = originalTitle;
                document.documentElement.style.removeProperty('--print-margin-left');
                document.documentElement.style.removeProperty('--print-margin-right');
                window.removeEventListener('afterprint', handleAfterPrint);
            };
            window.addEventListener('afterprint', handleAfterPrint);
            document.title = newTitle;
            window.print();
        }

        function handleScheduleActions() {
            const selectElement = document.getElementById('scheduleActionsSelect');
            const action = selectElement.value;
            if (action === 'reset') resetAllFixedSchedules();
            else if (action === 'backup') backupScheduleData();
            else if (action === 'restore') document.getElementById('restoreFile').click();
            selectElement.value = '';
        }

        function handleWorkTypeChange() {
            const vehicleSelect = document.getElementById('vehicleSelect');
            const workTypeSelect = document.getElementById('workTypeSelect');
            const colId = vehicleSelect.value;
            const workType = workTypeSelect.value;
            if (!colId || !workType) return;
            if (workType === 'normal' || workType === 'biweekly') {
                if (confirm(`차량 [${colId}]의 근무형태를 [${workType === 'normal' ? '3/3 근무' : '격주 근무'}]로 설정하고 저장하시겠습니까?`)) {
                    workTypeConfig[colId] = workType;
                    saveMasterData();
                    alert(`차량 [${colId}]의 근무형태가 [${workType === 'normal' ? '3/3 근무' : '격주 근무'}]로 설정되었습니다. '고정' 저장 시 적용됩니다.`);
                }
            }
            vehicleSelect.value = '';
            workTypeSelect.value = '';
        }
        
        function handleRouteSelectChange(routeName) {
            if (routeName) {
                loadRouteData(routeName);
            }
        }

        // --- 페이지 로드 시 실행 ---
        document.addEventListener('DOMContentLoaded', () => {
            const today = new Date();
            document.getElementById('yearInput').value = today.getFullYear();
            document.getElementById('monthInput').value = today.getMonth() + 1;
            const currentDay = today.getDate();
            if (currentDay <= 15) document.getElementById('option1').checked = true;
            else document.getElementById('option2').checked = true;
            
            loadMasterData();
            populateRouteSelect();
            loadRouteData(currentRoute); 

            // 날짜/요일 셀 클릭 시 편집 모드 해제 이벤트 리스너 추가
            document.getElementById('scheduleBody').addEventListener('click', clearEditMode);
        });
    </script>
</body>
</html>
